class Tank {
  float x, y, angle, turretAngle;
  float speed = 2.5;
  float rotationSpeed = 0.05;
  int size = 30;
  color tankColor;
  float hitBoxW = 30;
  float hitBoxH = 21;

  float maxHealth = 100;
  float currentHealth;
  boolean isAlive = true; // NEW: Track if the tank is active

  boolean movingForward = false;
  boolean movingBackward = false;
  boolean turningLeft = false;
  boolean turningRight = false;

  int lastShotTime = 0;
  int shootDelay = 30;

  Tank(float startX, float startY, color c) {
    x = startX;
    y = startY;
    angle = 0;
    tankColor = c;
    currentHealth = maxHealth;
    isAlive = true; // Ensure it starts alive
  }

  void update() {
    if (!isAlive) return; // Stop updates if destroyed

    // Movement and aiming logic remains the same as before
    if (movingForward) {
      x += cos(angle) * speed;
      y += sin(angle) * speed;
    }
    if (movingBackward) {
      x -= cos(angle) * speed;
      y -= sin(angle) * speed;
    }
    if (turningLeft) angle -= rotationSpeed;
    if (turningRight) angle += rotationSpeed;

    // Only update turret angle if it's the player tank (mouseX/mouseY only work for player input)
    // This part might need refinement if you want enemy tanks to use mouseX/mouseY logic
    // For the player tank, this is correct:
    if (this == playerTank) {
      turretAngle = atan2(mouseY - y, mouseX - x);
    }

    x = constrain(x, size/2, width - size/2);
    y = constrain(y, size/2, height - size/2);
  }

  void checkCollision(ArrayList<Wall> walls) {
    if (!isAlive) return;

    for (Wall w : walls) {
      // Axis-aligned bounding box (AABB) collision check
      if (x + hitBoxW/2 > w.x - w.w/2 && x - hitBoxW/2 < w.x + w.w/2 &&
        y + hitBoxH/2 > w.y - w.h/2 && y - hitBoxH/2 < w.y + w.h/2) {

        // Compute overlap distances in both axes
        float overlapX = (hitBoxW/2 + w.w/2) - abs(x - w.x);
        float overlapY = (hitBoxH/2 + w.h/2) - abs(y - w.y);

        // Resolve collision along the axis of least penetration
        if (overlapX < overlapY) {
          if (x < w.x) {
            x -= overlapX; // push left
          } else {
            x += overlapX; // push right
          }
        } else {
          if (y < w.y) {
            y -= overlapY; // push up
          } else {
            y += overlapY; // push down
          }
        }
      }
    }
  }

  void display() {
    if (!isAlive) return; // Don't draw if destroyed

    pushMatrix();
    translate(x, y);
    rotate(angle);

    stroke(4);
    fill(tankColor);
    rect(0, 0, size, size * 0.7);

    pushMatrix();
    rotate(turretAngle - angle);
    fill(100, 100, 100);
    rect(size * 0.35, 0, size * 0.7, size * 0.1);
    rect(0, 0, size * 0.6, size * 0.4);
    popMatrix();

    popMatrix();

    displayHealth(); // Call the health bar display function
  }

  void displayHealth() {
    if (!isAlive) return;
    float barWidth = 40;
    float barHeight = 5;
    float healthPercentage = currentHealth / maxHealth;

    // Background of health bar (red)
    fill(255, 0, 0);
    rect(x, y - size - 10, barWidth, barHeight);

    // Foreground of health bar (green)
    fill(0, 255, 0);
    rect(x - (barWidth/2) * (1 - healthPercentage), y - size - 10, barWidth * healthPercentage, barHeight);
  }

  void takeDamage(float damage) {
    currentHealth -= damage;
    if (currentHealth <= 0) {
      currentHealth = 0;
      isAlive = false; // Mark as destroyed
      println("Tank destroyed!");
    }
  }

  void shoot() {
    if (!isAlive) return; // Cannot shoot if destroyed
    if (millis() > lastShotTime + shootDelay * (1000/frameRate)) {
      bullets.add(new Bullet(x, y, turretAngle));
      lastShotTime = millis();
    }
  }
}
