class Tank {
  float x, y, angle, turretAngle;
  float speed = 2.5;
  float rotationSpeed = 0.05;
  int size = 30;
  color tankColor;
  float hitBoxW = 30;
  float hitBoxH = 21;

  float maxHealth = 100;
  float currentHealth;
  boolean isAlive = true; // Track if the tank is active

  boolean movingForward = false;
  boolean movingBackward = false;
  boolean turningLeft = false;
  boolean turningRight = false;

  int lastShotTime = 0;
  int shootDelay = 30;

  float recoilOffset = 0;       // how far back the muzzle is pushed
  float recoilMax = 10;         // maximum recoil distance
  float recoilRecoverySpeed = 1; // speed at which it returns

  Tank(float startX, float startY, color c) {
    x = startX;
    y = startY;
    angle = 0;
    tankColor = c;
    currentHealth = maxHealth;
    isAlive = true;
  }

  void update() {
    if (!isAlive) return;

    if (movingForward) {
      x += cos(angle) * speed;
      y += sin(angle) * speed;
    }
    if (movingBackward) {
      x -= cos(angle) * speed;
      y -= sin(angle) * speed;
    }
    if (turningLeft) angle -= rotationSpeed;
    if (turningRight) angle += rotationSpeed;

    if (this == playerTank) {
      turretAngle = atan2(mouseY - y, mouseX - x);
    }

    // Recoil recovery
    if (recoilOffset > 0) {
      recoilOffset -= recoilRecoverySpeed;
      if (recoilOffset < 0) recoilOffset = 0;
    }

    x = constrain(x, size/2, width - size/2);
    y = constrain(y, size/2, height - size/2);
  }

  void checkCollision(ArrayList<Wall> walls) {
    if (!isAlive) return;

    for (Wall w : walls) {
      // Axis-aligned bounding box (AABB) collision check
      if (x + hitBoxW/2 > w.x - w.w/2 && x - hitBoxW/2 < w.x + w.w/2 &&
        y + hitBoxH/2 > w.y - w.h/2 && y - hitBoxH/2 < w.y + w.h/2) {

        // Compute overlap distances in both axes
        float overlapX = (hitBoxW/2 + w.w/2) - abs(x - w.x);
        float overlapY = (hitBoxH/2 + w.h/2) - abs(y - w.y);

        // Resolve collision along the axis of least penetration
        if (overlapX < overlapY) {
          if (x < w.x) {
            x -= overlapX; // push left
          } else {
            x += overlapX; // push right
          }
        } else {
          if (y < w.y) {
            y -= overlapY; // push up
          } else {
            y += overlapY; // push down
          }
        }
      }
    }
  }

  void display() {
    if (!isAlive) return;

    pushMatrix();
    translate(x, y);
    rotate(angle);

    stroke(4);
    fill(tankColor);
    rect(0, 0, size, size * 0.7);

    pushMatrix();
    rotate(turretAngle - angle);

    // Apply recoil offset to turret
    translate(-recoilOffset, 0);

    fill(100, 100, 100);
    rect(size * 0.35, 0, size * 0.7, size * 0.1);
    rect(0, 0, size * 0.6, size * 0.4);
    noStroke();
    rect(size * 0.34, 0, size * 0.69, size * 0.09);
    stroke(4);
    popMatrix();

    popMatrix();

    displayHealth();
  }

  void displayHealth() {
    if (!isAlive) return;
    float barWidth = 40;
    float barHeight = 5;
    float healthPercentage = currentHealth / maxHealth;

    fill(255, 0, 0);
    rect(x, y - size - 10, barWidth, barHeight);

    fill(0, 255, 0);
    rect(x - (barWidth/2) * (1 - healthPercentage), y - size - 10, barWidth * healthPercentage, barHeight);
  }

  void takeDamage(float damage) {
    currentHealth -= damage;
    if (currentHealth <= 0) {
      currentHealth = 0;
      isAlive = false;
      println("Tank destroyed!");
    }
  }

  void shoot() {
    if (!isAlive) return;
    if (millis() > lastShotTime + shootDelay * (1000/frameRate)) {
      bullets.add(new Bullet(x, y, turretAngle));
      lastShotTime = millis();

      // Recoil
      recoilOffset = recoilMax;

      // Muzzle flash 
      pushMatrix();
      translate(x, y);
      rotate(turretAngle);
      noStroke();
      fill(#F5C505);
      ellipse(size * 0.9, 0, 25, 25);
      fill(#F59905);
      ellipse(size * 0.9, 0, 15, 15);
      popMatrix();
    }
  }
}
